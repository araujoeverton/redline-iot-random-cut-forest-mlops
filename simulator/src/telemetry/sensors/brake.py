"""
Brake Sensor Physics Model

Implements realistic brake system physics including:
- Friction heating: Q = μ * F * v
- Heat dissipation: Newton's law of cooling
- Brake fade: Exponential temperature-dependent friction degradation
- Pad wear: Proportional to braking force and duration
"""

import random
from typing import Dict
import numpy as np


class BrakeSensor:
    """
    Simulates brake system telemetry with realistic physics.

    Physics Models:
    - Disc Temperature: Friction heating + Newton's cooling
    - Brake Fade: μ_eff = μ_nom * exp(-fade_coeff * (T - T_nominal))
    - Pad Wear: Cumulative degradation from braking events
    """

    def __init__(
        self,
        fade_coefficient: float = 0.002,
        cooling_rate: float = 0.05,
        nominal_friction: float = 0.4,
        ambient_temp: float = 20.0,
    ):
        """
        Initialize brake sensor.

        Args:
            fade_coefficient: Brake fade temperature sensitivity (higher = more fade)
            cooling_rate: Heat dissipation rate (higher = faster cooling)
            nominal_friction: Nominal friction coefficient
            ambient_temp: Ambient air temperature (°C)
        """
        # State variables (4 wheels: FL, FR, RL, RR)
        self.disc_temp = np.array([ambient_temp] * 4, dtype=float)
        self.pad_wear = np.array([100.0] * 4, dtype=float)  # % remaining
        self.fluid_pressure = 0.0  # bar

        # Physics parameters
        self.fade_coefficient = fade_coefficient
        self.cooling_rate = cooling_rate
        self.nominal_friction = nominal_friction
        self.ambient_temp = ambient_temp

        # Braking state
        self.is_braking = False
        self.brake_force = 0.0

    def sample(self, timestamp: float) -> Dict[str, float]:
        """
        Generate one telemetry sample.

        Args:
            timestamp: Current timestamp (seconds)

        Returns:
            Dictionary with brake sensor readings
        """
        # Simulate braking event (30% probability)
        self.is_braking = random.random() < 0.3

        if self.is_braking:
            # Brake force: 0.5 to 1.0 (light to hard braking)
            self.brake_force = random.uniform(0.5, 1.0)

            # Fluid pressure proportional to brake force (max 120 bar)
            self.fluid_pressure = self.brake_force * 120.0

            # Heat generation (simplified model)
            # Q = μ * F * v (velocity assumed proportional to force)
            heat_generated = self._calculate_friction_heat(self.brake_force)
            self.disc_temp += heat_generated

            # Pad wear (proportional to brake force)
            self.pad_wear -= self.brake_force * 0.001

        else:
            self.fluid_pressure = 0.0

        # Heat dissipation (Newton's law of cooling)
        # dT/dt = -k * (T - T_ambient)
        self.disc_temp -= self.cooling_rate * (self.disc_temp - self.ambient_temp) * 0.1

        # Inject brake fade anomaly (10% chance when temp > 600°C)
        if np.any(self.disc_temp > 600) and random.random() < 0.1:
            self._inject_brake_fade()

        # Ensure physical constraints
        self.disc_temp = np.maximum(self.disc_temp, self.ambient_temp)
        self.pad_wear = np.clip(self.pad_wear, 0.0, 100.0)

        return {
            "brake_disc_temp_fl": float(self.disc_temp[0]),
            "brake_disc_temp_fr": float(self.disc_temp[1]),
            "brake_disc_temp_rl": float(self.disc_temp[2]),
            "brake_disc_temp_rr": float(self.disc_temp[3]),
            "brake_fluid_pressure": float(self.fluid_pressure),
            "brake_pad_wear_fl": float(self.pad_wear[0]),
            "brake_pad_wear_fr": float(self.pad_wear[1]),
            "brake_pad_wear_rl": float(self.pad_wear[2]),
            "brake_pad_wear_rr": float(self.pad_wear[3]),
        }

    def _calculate_friction_heat(self, brake_force: float) -> np.ndarray:
        """
        Calculate heat generated by friction.

        Heat generation is proportional to:
        - Brake force
        - Effective friction coefficient (degrades with temperature)
        - Velocity (assumed proportional to force for simplicity)

        Args:
            brake_force: Normalized brake force (0.0 to 1.0)

        Returns:
            Heat added to each disc (4-element array)
        """
        # Front-biased braking (60/40 split)
        front_bias = 0.6
        rear_bias = 0.4

        # Calculate effective friction coefficient (temperature-dependent)
        effective_friction = self.nominal_friction * np.exp(
            -self.fade_coefficient * (self.disc_temp - 200)
        )

        # Heat generation (simplified)
        # Q = μ * F * v (velocity factor)
        velocity_factor = brake_force * 100  # Assumed velocity proportional to force
        heat = effective_friction * brake_force * velocity_factor

        # Distribute heat to wheels
        heat_distribution = np.array(
            [
                heat * front_bias * 1.1,  # FL (slightly higher)
                heat * front_bias * 1.0,  # FR
                heat * rear_bias * 0.9,  # RL
                heat * rear_bias * 0.9,  # RR
            ]
        )

        # Add stochastic variation
        noise = np.random.normal(0, heat * 0.1, size=4)
        return heat_distribution + noise

    def _inject_brake_fade(self) -> None:
        """
        Inject brake fade anomaly.

        Simulates rapid temperature spike when brake fade occurs:
        - Exponential temperature rise
        - Loss of friction coefficient
        - Detectable as outlier in temperature distribution
        """
        # Find hottest disc
        fade_index = np.argmax(self.disc_temp)

        # Rapid temperature spike (brake fade signature)
        self.disc_temp[fade_index] += random.uniform(100, 200)

        # Optional: Log event for debugging
        # print(f"BRAKE FADE at wheel {fade_index}: {self.disc_temp[fade_index]:.1f}°C")
